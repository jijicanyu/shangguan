#define ITEM_UPDATE_INTERVAL 60

#define POWER_SMALLEST 1  
#define POWER_LARGEST  200  
#define CHUNK_ALIGN_BYTES 8  
#define MAX_NUMBER_OF_SLAB_CLASSES (POWER_LARGEST + 1)  

#define TAIL_REPAIR_TIME_DEFAULT 0

#define ITEM_key(item) (((char*)&((item)->data)) \
         + (((item)->it_flags & ITEM_CAS) ? sizeof(uint64_t) : 0))

#define ITEM_suffix(item) ((char*) &((item)->data) + (item)->nkey + 1 \
         + (((item)->it_flags & ITEM_CAS) ? sizeof(uint64_t) : 0))

#define ITEM_data(item) ((char*) &((item)->data) + (item)->nkey + 1 \
         + (item)->nsuffix \
         + (((item)->it_flags & ITEM_CAS) ? sizeof(uint64_t) : 0))

#define ITEM_ntotal(item) (sizeof(struct _stritem) + (item)->nkey + 1 \
         + (item)->nsuffix + (item)->nbytes \
         + (((item)->it_flags & ITEM_CAS) ? sizeof(uint64_t) : 0))


enum protocol {
    ascii_prot = 3, /* arbitrary value. */
    binary_prot,
    negotiating_prot /* Discovering the protocol */
};

enum item_lock_types {
    ITEM_LOCK_GRANULAR = 0,
    ITEM_LOCK_GLOBAL
};

#define ITEM_LINKED 1 //该item插入到LRU队列了  
#define ITEM_CAS 2 //该item使用CAS  
#define ITEM_SLABBED 4 //该item还在slab的空闲队列里面，没有分配出去  
#define ITEM_FETCHED 8 //该item插入到LRU队列后，被worker线程访问过 

//Item 缓存数据存储的基本单元
//1. Item是Memcached存储的最小单位
//2. 每一个缓存都会有自己的一个Item数据结构
//3. Item主要存储缓存的key、value、key的长度、value的长度、缓存的时间等信息。
//4. HashTable和LRU链表结构都是依赖Item结构中的元素的。
typedef struct _stritem {  
    //记录下一个item的地址,主要用于LRU链和freelist链  
    struct _stritem *next;  
    //记录下一个item的地址,主要用于LRU链和freelist链  
    struct _stritem *prev;  
    //记录HashTable的下一个Item的地址  
    struct _stritem *h_next;  
    //最近访问的时间，只有set/add/replace等操作才会更新这个字段  
    //当执行flush命令的时候，需要用这个时间和执行flush命令的时间相比较，来判断是否失效  
    rel_time_t      time;//最后一次访问时间。绝对时间
    //缓存的过期时间。设置为0的时候，则永久有效。  
    //如果Memcached不能分配新的item的时候，设置为0的item也有可能被LRU淘汰  
    rel_time_t      exptime;//过期失效时间，绝对时间
    //value数据大小  
    int             nbytes;//本item存放的数据的长度
    //引用的次数。通过这个引用的次数，可以判断item是否被其它的线程在操作中。  
    //也可以通过refcount来判断当前的item是否可以被删除，只有refcount -1 = 0的时候才能被删除  
    unsigned short  refcount;  
    uint8_t         nsuffix;//后缀长度
    uint8_t         it_flags;//item属性
    //slabs_class的ID。  
    uint8_t         slabs_clsid;//item属于哪个slab_class
    uint8_t         nkey;//key长度       /* key length, w/terminating null and padding */  
    /* this odd type prevents type-punning issues when we do 
     * the little shuffle to save space when not using CAS. */  
    //数据存储结构  
    union {  
        uint64_t cas;  
        char end;  
    } data[];  
    /* if it_flags & ITEM_CAS we have 8 bytes CAS */  
    /* then null-terminated key */  
    /* then " flags length\r\n" (no terminating null) */  
    /* then data with terminating \r\n (no terminating null; it's binary!) */  
} item;  



//为worker线程构建CQ队列：
//主线程又是怎么访问各个worker线程的CQ队列呢？
//在C语言里面的答案当然是使用全局变量啦。memcached专门定义了结构体，如下：

//看到LIBEVENT_THREAD结构体的这些成员，完全可以顾名思义。
//memcached定义了LIBEVENT_THREAD类型的一个全局变量指针threads。
//当确定了memcached有多少个worker线程后，就会动态申请一个LIBEVENT_THREAD数组，
//并让threads指向其。于是每一个worker线程都对应有一个LIBEVENT_THREAD结构体。
//主线程通过全局变量threads就可以很方便地访问每一个worker线程的CQ队列和通信管道。
typedef struct {
    pthread_t thread_id; //线程id        
    struct event_base *base; //线程所使用的event_base   
    struct event notify_event;//用于监听管道读事件的event  
    int notify_receive_fd; //管道的读端fd  
    int notify_send_fd;   //管道的写端fd  
    struct thread_stats stats;  /* Stats generated by this thread */
    struct conn_queue *new_conn_queue; /* queue of new connections to handle */
    cache_t *suffix_cache;      /* suffix cache */
    uint8_t item_lock_type;     /* use fine-grained or global item lock */
} LIBEVENT_THREAD;

typedef struct conn conn;

struct conn {
    int    sfd;
    sasl_conn_t *sasl_conn;
    bool authenticated;
    enum conn_states  state;
    enum bin_substates substate;
    rel_time_t last_cmd_time;
    struct event event;
    short  ev_flags;
    short  which;   /** which events were just triggered */

    char   *rbuf;   /** buffer to read commands into */
    char   *rcurr;  /** but if we parsed some already, this is where we stopped */
    int    rsize;   /** total allocated size of rbuf */
    int    rbytes;  /** how much data, starting from rcur, do we have unparsed */

    char   *wbuf;
    char   *wcurr;
    int    wsize;
    int    wbytes;
    /** which state to go into after finishing current write */
    enum conn_states  write_and_go;
    void   *write_and_free; /** free this memory after finishing writing */

    char   *ritem;  /** when we read in an item's value, it goes here */
    int    rlbytes;

    /* data for the nread state */

    /**
     * item is used to hold an item structure created after reading the command
     * line of set/add/replace commands, but before we finished reading the actual
     * data. The data is read into ITEM_data(item) to avoid extra copying.
     */

    void   *item;     /* for commands set/add/replace  */

    /* data for the swallow state */
    int    sbytes;    /* how many bytes to swallow */

    /* data for the mwrite state */
    struct iovec *iov;
    int    iovsize;   /* number of elements allocated in iov[] */
    int    iovused;   /* number of elements used in iov[] */

    struct msghdr *msglist;
    int    msgsize;   /* number of elements allocated in msglist[] */
    int    msgused;   /* number of elements used in msglist[] */
    int    msgcurr;   /* element in msglist[] being transmitted now */
    int    msgbytes;  /* number of bytes in current msg */

    item   **ilist;   /* list of items to write out */
    int    isize;
    item   **icurr;
    int    ileft;

    char   **suffixlist;
    int    suffixsize;
    char   **suffixcurr;
    int    suffixleft;

    enum protocol protocol;   /* which protocol this connection speaks */
    enum network_transport transport; /* what transport is used by this connection */

    /* data for UDP clients */
    int    request_id; /* Incoming UDP request ID, if this is a UDP "connection" */
    struct sockaddr_in6 request_addr; /* udp: Who sent the most recent request */
    socklen_t request_addr_size;
    unsigned char *hdrbuf; /* udp packet headers */
    int    hdrsize;   /* number of headers' worth of space is allocated */

    bool   noreply;   /* True if the reply should not be sent. */
    /* current stats command */
    struct {
        char *buffer;
        size_t size;
        size_t offset;
    } stats;

    /* Binary protocol stuff */
    /* This is where the binary header goes */
    protocol_binary_request_header binary_header;
    uint64_t cas; /* the cas to return */
    short cmd; /* current command being processed */
    int opaque;
    int keylen;
    conn   *next;     /* Used for generating a list of conn structures */
    LIBEVENT_THREAD *thread; /* Pointer to the thread object serving this connection */
};// end struct conn{..};

