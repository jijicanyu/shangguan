http://blog.csdn.net/ruglcc/article/details/7814546/

make是一个命令工具，是一个解释makefile中指令的命令工具

C程序编译和连接:
编译是生成.o文件,连接时把.o文件合成可执行文件
把大量.o文件打包就是库文件.a或者.so

1 Makefile 介绍
如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。
如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。
如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。

###################################################################################
1.1 Makefile的规则
格式:
target... : prerequisites ...
command
...
...

target:
可以是一个目标文件，
可以是Object File，
也可以是执行文件,还可以是一个标签（Label），
对于标签这种特性，在后续的“伪目标”章节中会有叙述。

prerequisites:
要生成那个target所需要的文件或是目标。

command:
也就是make需要执行的命令。（任意的Shell命令）

这是一个文件的依赖关系，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。
prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。
这就是Makefile的规则。也就是Makefile中最核心的内容。
###################################################################################
1.2 一个示例
代码:2.example2/1.makefile
###################################################################################
1.3 make是如何工作的

make会在当前目录下找名字叫“Makefile”或“makefile”的文件。

如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，
他会找到“edit”这个文件，并把这个文件作为最终的目标文件。

如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比edit这个文件新，
那么，他就会执行后面所定义的命令来生成edit这个文件。

如果edit所依赖的.o文件也存在，那么make会在当前文件中找目标为.o文件的依赖性，
如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程）

当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件声明make的终极任务，也就是执行文件edit了。
###################################################################################
1.4 makefile中使用变量
代码:2.example2/2.makefile
###################################################################################
1.5 让make自动推导
代码:2.example2/3.makefile
make自动推导文件以及文件依赖关系后面的命令，于是没必要在每个[.o]文件后都写上类似的命令，make会自动识别，并自己推导命令。

只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中.
如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。
并且 cc -c whatever.c 也会被推导出来，我们的makefile再也不用写得这么复杂。
###################################################################################
1.6 另类风格的makefile
代码:2.example2/4.makefile
我看到那堆[.o]和[.h]的依赖就有点不爽，那么多的重复的[.h]，能不能把其收拢起来，
这个对于make来说很容易，谁叫它提供了自动推导命令和文件的功能呢？来看看最新风格的makefile吧。

我们的makefile变得很简单，但我们的文件依赖关系就显得有点凌乱了
我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多，要加入几个新的.o文件，那就理不清楚了。
###################################################################################
1.7 清空目标文件的规则
每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁
类似:
clean:
	rm edit $(objects)
更为稳健的做法是：
.PHONY : clean
clean :
	-rm edit $(objects)

.PHONY意思表示clean是一个“伪目标”。
rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。

clean的规则不要放在文件的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。
不成文的规矩是“clean从来都是放在文件的最后”。

###################################################################################
2 Makefile 总述
2.1 Makefile里有什么？
Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。


显式规则:
显式规则说明了，如何生成一个或多的的目标文件。
这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。

隐晦规则:
由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。

变量的定义:
在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点像C语言中的宏，
当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。

文件指示:
其包括了三个部分，
一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；
另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；
还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。

注释:
Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。
如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“\#”。

最后，还值得一提的是，在Makefile中的命令，必须要以[Tab]键开始。
###################################################################################
2.2Makefile的文件名
Makefile > makefile

make -f 1.makefile
make -file 1.makefile
###################################################################################
2.3 引用其它的Makefile
include<filename>:
filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符）
在include前面可以有一些空字符，但是绝不能是[Tab]键开始。include和可以用一个或多个空格隔开

例如:
你有这样几个Makefile：a.mkb.mk c.mk e.mk f.mk foo.make

bar=e.mk f.mk
include foo.make *.mk $(bar)
等价于：
include foo.make a.mk b.mk c.mk e.mk f.mk

inclue的顺序:
0.默认当前路径找
1.如果make执行时，有“-I”或“--include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。
2.如果目录/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。

-include<filename>的作用:
如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。
它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还不行，才会现致命信息。
如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。
其表示，无论include过程中出现什么错误，都不要报错继续执行。
和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。
###################################################################################
2.4 环境变量 MAKEFILES
如果你的当前环境中定义了环境变量MAKEFILES，make会把这个变量中的值做一个类似于include的动作。
这个变量中的值是其它的Makefile，用空格分隔。
它和include不同的是，从这个环境变中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。

不建议要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的Makefile都会受到它的影响。
也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。
###################################################################################
2.5 make的工作方式

1.读入所有的Makefile。
2.读入被include的其它Makefile。
3.初始化文件中的变量。
4.推导隐晦规则，并分析所有规则。
5.为所有的目标文件创建依赖关系链。
6.根据依赖关系，决定哪些目标要重新生成。
7.执行生成命令。


1-5步为第一个阶段，6-7为第二个阶段。
第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。
make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，
那么仅当这条依赖被决定要使用了，变量才会在其内部展开。
这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。
###################################################################################
3. Makefile书写规则
规则包含两个部分，一个是依赖关系，一个是生成目标的方法。

在Makefile中，规则的顺序是很重要的.
Makefile中只应该有一个最终目标，其它的目标都是被这个目标所连带出来的，一定要让make知道你的最终目标是什么。
一般定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。
如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make所完成的也就是这个目标。
###################################################################################
3.1 规则举例
# foo模块
foo.o: foo.c defs.h
	cc -c -g foo.c

foo.o是我们的目标，foo.c和defs.h是目标所依赖的源文件
###################################################################################
3.2 规则的语法
     targets : prerequisites
       command
       ...
或是这样：
     targets : prerequisites ; command
           command
           ...
###################################################################################
3.3 在规则中使用通配符
make支持三各通配符：“*”，“?”和“[...]”

"~"
波浪号（“~”）字符在文件名中也有比较特殊的用途。
Liunx:“~/test”，这就表示当前用户的$HOME目录下的test目录。 而“~hchen/test”则表示用户hchen的宿主目录下的test目录。
Windows或是MS-DOS下:
用户没有宿主目录，那么波浪号所指的目录则根据环境变量“HOME”而定。

"*"
通配符代替了你一系列的文件，如“*.c”表示所以后缀为c的文件。
注意的是，如果我们的文件名中有通配符，
如：“*”，那么可以用转义字符“\”，如“\*”来表示真实的“*”字符，而不是任意长度的字符串。
###################################################################################
3.4 文件搜寻
当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。

1.VPATH常量:
如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。
VPATH = src:../headers
上面的的定义指定两个目录，“src”和“../headers”，make会按照这个顺序进行搜索。
目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）

2.vpath关键字:
vpath更为灵活。它可以指定不同的文件在不同的搜索目录中。
它的使用方法有三种：
2.1. vpath <pattern> <directories>    为符合模式<pattern>的文件指定搜索目录<directories>。
2.2. vpath <pattern>                  清除符合模式<pattern>的文件的搜索目录。
2.3. vpath                            清除所有已被设置好了的文件搜索目录。

vapth使用方法中的<pattern>需要包含“%”字符。
“%”的意思是匹配零或若干字符，例如，“%.h”表示所有以“.h”结尾的文件。
<pattern>指定了要搜索的文件集，
<directories>则指定了的文件集的搜索的目录。
例:
vpath %.h ../headers
该语句表示，要求make在“../headers”目录下搜索所有以“.h”结尾的文件。（如果某文件在当前目录没有找到的话）

3.连续地使用vpath语句，以指定不同搜索策略。
如果连续的vpath语句中出现了相同的<pattern>，
或是被重复了的<pattern>，那么，make会按照vpath语句的先后顺序来执行搜索

例如:
其表示“.c”结尾的文件，先在“foo”目录，然后是“blish”，最后是“bar”目录。
vpath %.c foo
vpath %   blish
vpath %.c bar

例如:
而上面的语句则表示“.c”结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录。
vpath %.c foo:bar
vpath %   blish
###################################################################################
3.5 伪目标
为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。
.PHONY: clean
	clean:
	rm *.o temp

伪目标指定所依赖的文件。
伪目标同样可以作为“默认目标”，只要将其放在第一个。

例如:如果Makefile要一口气生成若干个可执行文件，但只想简单地敲一个make，
所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性：
make -f 1.PHONY
###################################################################################
3.6 多目标
里面的例子没能实现, $@只能打印多目标中的第一个
[root@web11 3.6.multi_targets]# make -f 1.mutli_targets
echo aaaa
aaaa
###################################################################################
3.7 静态模式
静态模式可以更加容易地定义多目标的规则
语法：
<targets...>: <target-pattern>: <prereq-patterns ...>
	<commands>
	...

targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。
target-parrtern是指明了targets的模式，也就是的目标集模式。
prereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。


如果我们的<target-parrtern>定义成“%.o”，意思是我们的集合中都是以“.o”结尾的.
而如果我们的<prereq-parrterns>定义成“%.c”，意思是对<target-parrtern>所形成的目标集进行二次定义.
其计算方法是，取<target-parrtern>模式中的“%”（也就是去掉了[.o]这个结尾），并为其加上[.c]这个结尾，形成的新集合。

如果你的文件名中有“%”那么你可以使用反斜杠“\”进行转义，来标明真实的“%”字符。
###################################################################################
3.8 自动生成依赖性
1.初步:
如果我们的main.c中有一句“#include "defs.h"”，那么我们的依赖关系应该是：
main.o : main.c defs.h

2.通过编译器查看一个文件的依赖关系
gcc -M main.c:标准库头+自定义裤头
gcc -MM main.c:自定义库头

[root@web11 3.8auto_create_dependency]# gcc -M main.c
main.o: main.c defs.h
###################################################################################
4 Makefile 书写命令
make的命令默认是被“/bin/sh”——UNIX的标准Shell解释执行的
###################################################################################
4.1 显示命令
1.makefile:
@echo 正在编译XXX模块......
输出:
正在编译XXX模块......


2.makefile:
echo 正在编译XXX模块......
输出:
echo 正在编译XXX模块......
   正在编译XXX模块......

3.make -n或--just-print，那么其只是显示命令，但不会执行命令。
4.make参数“-s”或“--slient”则是全面禁止命令的显示。
###################################################################################
4.2 命令执行
当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。
如果两条命令要连续执行,之间要用分号不能是两条语句

###################################################################################
4.3 命令出错
当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，make会执行下一条命令，当规则中所有的命令成功返回后, 这个规则就算是成功完成了。
如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。

有时，命令的出错并不表示就是错误的。
mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。
使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。

方法1:命令前加"-"
-mkdir xxx

方法2:全局的办法 make “-i”或是“--ignore-errors”

方法3:
一个规则是以“.IGNORE”作为目标的，这个规则中的所有命令将会忽略错误。
这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。

方法4:
make的参数的是“-k”或是“--keep-going”，如果某规则中的命令出错了，那么就终目该规则的执行，但继续执行其它规则。
###################################################################################
4.4 嵌套执行make
subsystem:
	cd subdir && $(MAKE)
其等价于：
subsystem:
	$(MAKE) -C subdir

总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），
但不会覆盖下层的Makefile中所定义的变量，除非指定了“-e”参数。

如果你要传递变量到下级Makefile中，那么你可以使用这样的声明：
export<variable ...>
如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明：
unexport<variable ...>

示例一：
export variable = value
其等价于：
variable = value
export variable
其等价于：
export variable := value
其等价于：
variable := value
export variable

示例二：
export variable += value
其等价于：
variable += value
export variable

如果你要传递所有的变量，那么，只要一个export就行了。后面什么也不用跟，表示传递所有的变量。

SHELL，MAKEFLAGS，这两个变量不管你是否export，其总是要传递到下层Makefile中
MAKEFILES变量，其中包含了make的参数信息，执行“总控Makefile”时有make参数或是在上层Makefile中定义了这个变量，MAKEFILES变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。


make命令中的有几个参数并不往下传递，它们是“-C”,“-f”,“-h”“-o”和"-W"

如果你不想往下层传递参数，那么，你可以这样来：
subsystem:
	cd subdir && $(MAKE) MAKEFLAGS=

如果定义了环境变量MAKEFLAGS，那么你得确信其中的选项是大家都会用到的，
如果其中有“-t”,“-n”,和“-q”参数，那么将会有意想不到的结果。

make "-w"或是"--print-directory"会在make的过程中输出一些信息，让你看到目前的工作目录。
make: Entering directory `/home/hchen/gnu/make'.
make: Leaving directory `/home/hchen/gnu/make'

make "-C"参数来指定make下层Makefile时，“-w”会被自动打开的。
如果参数中有“-s”（“--slient”）或是“--no-print-directory”，那么，“-w”总是失效的。


###################################################################################

4.5 定义命令包
###################################################################################
