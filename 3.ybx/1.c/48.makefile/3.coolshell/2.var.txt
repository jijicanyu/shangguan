http://blog.csdn.net/ruglcc/article/details/7814546/

Makefile中的变量，像C/C++的宏，代表一个文本字串.
其与C/C++所不同的是，你可以在Makefile中改变其值。
在Makefile中，变量可以使用在“目标”，“依赖目标”，“命令”或是 Makefile的其它部分中。
变量的命名字可以包含字符、数字，下划线（可以是数字开头），
但不应该含有“:”、“#”、“=”或是空字符（空格、回车等）。
变量是大小写敏感的，“foo”、“Foo”和“FOO”是三个不同的变量名。
传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。
这样可以避免和系统的变量冲突，而发生意外的事情。

一、变量的基础
变量在声明时需要给予初值，而在使用时，需要给在变量名前加上“$”符号，最好用（）或{}把变量给包括起来。
如果要用真实的“$”字符，那么你需要用“$$”来表示。
变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。

######################################################################################
二、变量中的变量
1.Makefile中有两种方式来在用变量定义变量的值。

第一种方式: =号
右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值
优点:
可以引用还没定义的变量
缺点:
可能会带来错误
例如:
A = $(B)
B = $(A)

第二种方式: := 操作符
这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量
x := foo
y := $(x) bar
x := later
其等价于：
y := foo bar
x := later

2.系统变量“MAKELEVEL”，这个变量会记录了我们的当前Makefile的调用层数。

########################################################################################
三、变量高级用法
介绍两种变量的高级使用方法

第一种是变量值的替换:
make -f 1.var_value_replace
make -f make -f 2.var_value_replace

第二种高级用法是把变量的值再当成变量:
make -f 3.var_value_as_var_name
make -f 4.var_value_as_var_name
########################################################################################
四、追加变量值
objects = main.o foo.o bar.o utils.o
objects += another.o
同上
objects = main.o foo.o bar.o utils.o
objects := $(objects) another.o

如果变量之前没有定义过，那么，“+=”会自动变成“=”，
如果前面有变量定义，那么“+=”会继承于前次操作的赋值符。
如果前一次的是“:=”，那么“+=”会以“:=”作为其赋值符
variable := value
variable += more
等价于：
variable := value
variable := $(variable) more
########################################################################################
五、override 指示符
如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。
如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是：

override <variable> = <value>
override <variable> := <value>
override <variable> += <more text>
########################################################################################
六、多行变量
还有一种设置变量值的方法是使用define关键字。
使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令
（前面我们讲过“命令包”的技术就是利用这个关键字）。

define 后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef关键字结束。
其工作方式和“=”操作符一样。
变量的值可以包含函数、命令、文字，或是其它变量。
因为命令需要以[Tab]键开头，所以如果你用define定义的命令变量中没有以[Tab]键开头，那么make就不会把其认为是命令。
########################################################################################
七、环境变量
make运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中.
但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。
（如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）

如果在环境变量中设置了“CFLAGS”环境变量，就可以在所有的Makefile中使用这个变量了。
这对于使用统一的编译参数有比较大的好处。
如果Makefile中定义了CFLAGS，则会使用Makefile中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很像“全局变量”和“局部变量”的特性。
当make嵌套调用时,上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile中。
默认，只有通过命令行设置的变量会被传递。
而定义在文件中的变量，如果要向下层 Makefile传递，则需要使用exprot关键字来声明。

########################################################################################
八、目标变量
1.全局变量和自动变量:
前面Makefile中定义的变量是“全局变量”，在整个文件，都可以访问
自动化变量则不能在整个文件访问，如“$<”等这种就属于“规则型变量”，其值依赖于规则的目标和依赖目标的定义。

2.为某个目标设置局部变量:
这种变量被称为“Target-specific Variable”，它可以和“全局变量”同名.
因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。

其语法是：
<target ...> : <variable-assignment>
<target ...> : overide <variable-assignment>

<variable-assignment>可以是前面讲过的各种赋值表达式，如“=”、“:=”、“+=”或是“？=”。
第二个语法是针对于make命令行带入的变量，或是系统环境变量。

这个特性非常有用，当设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去
########################################################################################
九、模式变量
1.定义:
在GNU的make中，还支持模式变量（Pattern-specific Variable），通过上面的目标变量中，知道，变量可以定义在某个目标上。
模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。

2.实例:
make的模式一般是至少含有一个“%”的，
我们可以以如下方式给所有以[.o]结尾的目标定义目标变量：
%.o : CFLAGS = -O

3.语法:
同样，模式变量的语法和“目标变量”一样：
<pattern ...> : <variable-assignment>
<pattern ...> : override <variable-assignment>
override同样是针对于系统环境传入的变量，或是make命令行指定的变量。

########################################################################################
########################################################################################
########################################################################################
########################################################################################
