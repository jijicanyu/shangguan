http://www.blogjava.net/yongboy/archive/2015/04/14/424413.html

SO_KEEPALIVE的用处就类似hplsp11中的定义器
服务器对空闲的客户端通过发tcp-keepalive包来进行健康情况监控

客户端正常将会响应tcp-keepalive ack

客户端非正常关闭,例如拔掉网线,就不能响应了,
服务端并会在read返回-1,errno设置ETIMEOUT超时错误
服务器就可以关闭此连接来降低负载

=================================================================
wireshark:进行测试的监控
tcp and tcp.port == 1234
=================================================================

测试1:
因为服务器使用了keepalive 可以很快发现客户端异常断开,
time out 然后关闭客户端连接

192.168.91.11:
./1.server 192.168.91.11 1234 yes
use keep-alive
radd:0.0.0.0 rport:0
error:Connection timed out

192.168.91.138:
nc 192.168.91.11 1234
这台虚拟机关闭网络连接

=================================================================
测试2:
因为服务器没有使用了keepalive 客户端异常断开网络后服务器不能发现
192.168.91.11:
./1.server 192.168.91.11 1234 yes
use keep-alive
radd:0.0.0.0 rport:0

192.168.91.138:
nc 192.168.91.11 1234
这台虚拟机关闭网络连接

